# 기술 요구사항 명세서 (TRD)

## 1. 기술 요약
### 프로젝트 개요
본 프로젝트는 국회의원 및 예비후보 선거 캠프를 위한 '정치 생산성 허브'의 MVP 버전(모듈 1: 메시징 & 연락처 코어)을 개발하는 것을 목표로 합니다. Next.js 15 기반의 반응형 프론트엔드와 .NET 9 기반의 고성능 백엔드를 통해 대량의 유권자 연락처를 효율적으로 관리하고, SMS 및 카카오 메시지를 정확하고 신속하게 발송하는 웹 애플리케이션을 구축합니다. 시스템 전반은 Docker를 통해 컨테이너화하여 베어메탈 서버 환경에 안정적으로 배포 및 운영합니다.

### 핵심 기술 스택
- **프론트엔드**: Next.js 15, TypeScript, shadcn/ui, Tailwind CSS, TanStack Query
- **백엔드**: .NET 9 Minimal API, Entity Framework Core
- **데이터베이스**: PostgreSQL 16 (RLS, pgcrypto 활용)
- **인프라 & 메시징 큐**: Docker, Redis
- **인증**: Supabase Auth
- **모니터링**: Prometheus, Grafana

### 주요 기술 목표
- **성능**: 10만 건의 CSV 연락처를 10분 이내에 업로드 및 처리하고, 1만 건의 메시지를 20분 이내에 발송 완료 (초당 약 8.3건 이상). p95 검색 응답 시간 150ms 미만 달성.
- **확장성**: 향후 메시징 채널(이메일, 텔레그램 등) 추가 및 기능 확장을 고려한 모듈식 아키텍처 설계.
- **신뢰성**: 메시지 중복 발송 및 오발송률 0.1% 미만 유지. 데이터베이스 이중화 및 실시간 모니터링을 통한 시스템 가용성 확보.
- **보안**: 테넌트별 데이터 격리를 위한 RLS(Row-Level Security) 적용 및 개인정보(PII) 데이터 암호화.

### 핵심 기술 가정
- 지정된 기술 스택(.NET, Next.js, PostgreSQL 등)은 프로젝트의 성능 및 보안 요구사항을 충족하기에 충분합니다.
- 외부 SMS 및 카카오 알림톡 API는 명시된 발송 속도(초당 50건)를 지원하며, 연동에 기술적 제약이 없습니다.
- 베어메탈 서버 환경(Ubuntu 24.04)은 Docker 컨테이너 실행을 위한 안정적인 기반을 제공합니다.
- Supabase Auth는 테넌트 기반의 사용자 인증 및 역할 관리 요구사항을 충족할 수 있습니다.

## 2. 기술 스택

| 카테고리 | 기술 / 라이브러리 | 선정 사유 |
|---|---|---|
| **프론트엔드 프레임워크** | Next.js 15 | 서버 컴포넌트를 활용하여 초기 로딩 성능을 최적화하고, 풍부한 생태계를 통해 신속한 UI 개발이 가능합니다. |
| **UI 컴포넌트** | shadcn/ui, lucide-react, Tailwind CSS | 높은 수준의 커스터마이징이 가능하며, 일관성 있고 접근성 높은 UI를 빠르게 구축할 수 있습니다. |
| **상태 관리 & 데이터 페칭** | @tanstack/react-query | 서버 상태 관리를 단순화하고 캐싱, 재시도, 실시간 업데이트 기능을 통해 사용자 경험과 성능을 향상시킵니다. |
| **유틸리티** | es-toolkit, date-fns | 경량화된 유틸리티 라이브러리를 사용하여 번들 사이즈를 최소화하고, 날짜 관련 로직을 안정적으로 처리합니다. |
| **백엔드 프레임워크** | .NET 9 | 고성능, 비동기 처리 능력이 뛰어나 대량 데이터 처리 및 메시지 발송과 같은 I/O 집약적 작업에 적합합니다. |
| **데이터베이스** | PostgreSQL 16 | RLS, pgcrypto와 같은 강력한 보안 기능을 내장하고 있으며, 대용량 데이터 처리에 대한 안정성과 성능이 검증되었습니다. |
| **인메모리 데이터 저장소** | Redis | 메시지 발송 큐 및 실시간 대시보드 데이터 캐싱 용도로 사용하여 백엔드의 부하를 줄이고 응답 속도를 향상시킵니다. |
| **인프라 & 배포** | Docker | 개발, 테스트, 프로덕션 환경의 일관성을 보장하고, 베어메탈 서버에 애플리케이션을 격리하여 안정적으로 배포합니다. |
| **모니터링** | Prometheus, Grafana | 시스템의 핵심 메트릭(CPU, 메모리, 발송량 등)을 실시간으로 수집하고 시각화하여 장애 발생 시 신속하게 대응할 수 있습니다. |

## 3. 시스템 아키텍처 설계

### 최상위 구성 요소
- **프론트엔드 웹 애플리케이션 (Next.js)**
  - 사용자 인터페이스(UI) 및 사용자 경험(UX)을 담당합니다.
  - 구성 요소: 연락처 관리 대시보드, 캠페인 생성 마법사, 실시간 성과 분석 대시보드.
  - TanStack Query를 통해 백엔드 API와 비동기 통신을 수행합니다.
- **백엔드 API 서버 (.NET 9)**
  - 모든 비즈니스 로직을 처리하는 핵심 서버입니다.
  - 구성 요소: 연락처 처리 API, 캠페인 관리 API, 통계 집계 API.
  - Supabase Auth와 연동하여 사용자 인증/인가를 처리하고, 외부 메시징 게이트웨이(SMS, 카카오)와 통신합니다.
- **데이터베이스 (PostgreSQL 16)**
  - 모든 영구 데이터를 저장합니다.
  - 구성 요소: 사용자/테넌트 정보, 연락처 데이터, 캠페인 정보, 발송 로그.
  - RLS를 통해 테넌트 간 데이터 격리를 보장하고, pgcrypto로 민감 정보를 암호화합니다.
- **메시지 큐 (Redis)**
  - 대량 메시지 발송 요청을 처리하는 비동기 작업 큐입니다.
  - 구성 요소: 발송 대기열, 발송 결과 처리 큐.
  - 백엔드 서버의 부하를 분산시키고 안정적인 메시지 발송을 보장합니다.
- **모니터링 시스템 (Prometheus & Grafana)**
  - 시스템의 상태와 성능을 실시간으로 모니터링합니다.
  - 구성 요소: 메트릭 수집기(Prometheus), 시각화 대시보드(Grafana).

### 최상위 컴포넌트 상호작용 다이어그램
```mermaid
graph TD
    subgraph 사용자 환경
        A[사용자 브라우저]
    end

    subgraph 클라우드/인프라
        B[프론트엔드 (Next.js on Docker)]
        C[백엔드 API (.NET on Docker)]
        D[데이터베이스 (PostgreSQL on Docker)]
        E[메시지 큐 (Redis on Docker)]
        F[모니터링 (Prometheus/Grafana)]
        G[Supabase Auth]
        H[외부 메시징 게이트웨이 (SMS/Kakao)]
    end

    A -- HTTPS --> B
    B -- API 요청 --> C
    C -- 인증/인가 --> G
    C -- 데이터 CRUD --> D
    C -- 발송 작업 Enqueue/Dequeue --> E
    C -- 메시지 발송 요청 --> H
    
    B -- 실시간 통계 요청 --> C
    C -- 시스템 메트릭 --> F
    D -- 시스템 메트릭 --> F
    E -- 시스템 메트릭 --> F
```
- **사용자 요청 처리**: 사용자는 브라우저를 통해 Next.js 프론트엔드와 상호작용합니다. 프론트엔드는 백엔드 API 서버(.NET)에 데이터 요청 및 비즈니스 로직 실행을 요청합니다.
- **인증 및 데이터 처리**: 백엔드 API는 Supabase Auth를 통해 모든 요청의 사용자를 인증하고, PostgreSQL 데이터베이스에서 데이터를 읽거나 씁니다.
- **비동기 메시지 발송**: 대량 메시지 발송 요청이 들어오면, 백엔드는 즉시 처리하지 않고 Redis 메시지 큐에 작업을 등록합니다. 별도의 워커 프로세스가 큐에서 작업을 가져와 외부 메시징 게이트웨이를 통해 순차적으로 발송합니다.
- **모니터링**: Prometheus는 각 컴포넌트(백엔드, DB, Redis)의 상태 및 성능 지표를 수집하고, Grafana는 이를 시각화하여 운영자가 시스템 상태를 한눈에 파악할 수 있도록 돕습니다.

### 코드 구성 및 규칙
**도메인 주도 구성 전략**
- **도메인 분리**: 코드를 비즈니스 도메인(예: `Contacts`, `Campaigns`, `Analytics`, `Tenants`) 중심으로 구성하여 응집도를 높이고 결합도를 낮춥니다.
- **계층 기반 아키텍처**: 각 도메인 내에서 Presentation(API 컨트롤러), Application(비즈니스 로직), Domain(핵심 모델), Infrastructure(DB, 외부 서비스 연동) 계층으로 명확히 분리합니다.
- **기능 기반 모듈**: 특정 기능과 관련된 모든 코드(UI 컴포넌트, API 엔드포인트, 서비스 로직, 데이터 모델)를 하나의 폴더/모듈에 그룹화합니다.
- **공유 컴포넌트**: 여러 도메인에서 공통으로 사용되는 유틸리티, 타입 정의, UI 컴포넌트 등은 별도의 `shared` 또는 `common` 모듈에 배치합니다.

**범용 파일 및 폴더 구조**
```
/
├── frontend/ (Next.js)
│   ├── src/
│   │   ├── app/                # 라우팅 및 페이지
│   │   ├── components/         # 재사용 가능한 UI 컴포넌트 (shadcn)
│   │   │   ├── shared/
│   │   │   └── features/
│   │   ├── features/           # 도메인/기능별 모듈 (e.g., contacts, campaigns)
│   │   │   ├── contacts/
│   │   │   │   ├── api/        # 데이터 페칭 로직
│   │   │   │   ├── components/ # 연락처 관련 UI
│   │   │   │   └── types.ts    # 타입 정의
│   │   │   └── ...
│   │   ├── lib/                # 유틸리티, 훅
│   │   └── types/              # 전역 타입
│   └── ...
├── backend/ (.NET)
│   ├── src/
│   │   ├── Api/                # API 프로젝트 (컨트롤러, 미들웨어)
│   │   ├── Application/        # 비즈니스 로직 (서비스, CQRS 핸들러)
│   │   ├── Domain/             # 핵심 도메인 모델, 엔티티
│   │   └── Infrastructure/     # 데이터베이스(EF Core), 외부 서비스 연동
│   └── ...
├── docker-compose.yml
└── ...
```

### 데이터 흐름 및 통신 패턴
- **클라이언트-서버 통신**: 프론트엔드는 TanStack Query를 사용하여 백엔드 .NET API에 RESTful 요청을 보냅니다. 모든 데이터 교환은 JSON 형식을 사용합니다.
- **데이터베이스 상호작용**: .NET 백엔드는 Entity Framework Core(ORM)를 사용하여 PostgreSQL 데이터베이스와 상호작용합니다. 대량 데이터 입력 시에는 EF Core의 Bulk Insert 기능 또는 PostgreSQL의 `COPY` 명령을 활용하여 성능을 최적화합니다.
- **외부 서비스 통합**: 외부 SMS/카카오 API 연동은 `Infrastructure` 계층에 구현된 전용 클라이언트 서비스를 통해 이루어집니다. HttpClientFactory를 사용하여 연결을 효율적으로 관리합니다.
- **실시간 통신**: 발송 현황 대시보드는 5초 주기의 폴링(Polling) 방식으로 TanStack Query를 통해 최신 데이터를 백엔드에 요청하여 실시간에 가까운 업데이트를 제공합니다.
- **데이터 동기화**: Redis 큐를 통해 메시지 발송 작업이 비동기적으로 처리되므로, 발송 상태(성공, 실패)는 워커가 처리한 후 데이터베이스에 업데이트됩니다. 프론트엔드는 이 업데이트된 데이터를 조회하여 사용자에게 보여줍니다.

## 4. 성능 및 최적화 전략
- **대용량 업로드 처리**: 10만 건 이상의 CSV 파일 업로드 시, 전체 파일을 메모리에 로드하는 대신 스트리밍 방식으로 처리하고, 백그라운드 작업으로 전환하여 사용자에게 즉각적인 UI 응답을 제공합니다. 데이터베이스에는 PostgreSQL의 `COPY` 명령어를 사용하여 고속으로 데이터를 적재합니다.
- **비동기 메시지 발송**: Redis Streams를 메시지 큐로 활용하여 대량 발송 요청을 비동기적으로 처리합니다. API 서버는 발송 요청을 큐에 추가하는 역할만 담당하고, 별도의 워커(Worker) 프로세스가 큐에서 작업을 가져와 실제 발송을 처리함으로써 API 서버의 부하를 최소화합니다.
- **데이터베이스 최적화**: 연락처 검색, 필터링 등 주요 조회 쿼리에 대해 복합 인덱스(Composite Index)를 생성하여 응답 시간을 단축합니다. 또한, 통계 데이터는 정기적으로 집계하여 별도의 요약 테이블에 저장함으로써 대시보드 로딩 성능을 향상시킵니다.
- **프론트엔드 성능**: Next.js의 서버 컴포넌트와 코드 스플리팅을 적극 활용하여 초기 페이지 로딩 속도를 개선합니다. 가상화(Virtualization) 기술을 적용하여 대규모 연락처 목록을 렌더링할 때 브라우저의 부담을 줄입니다.

## 5. 구현 로드맵 및 마일스톤
### 1단계: 기반 구축 (MVP 구현)
- **핵심 인프라**: Docker Compose를 이용한 개발/운영 환경 구성, PostgreSQL 및 Redis 설정. Supabase Auth를 이용한 테넌트 모델 및 인증/인가 구현.
- **필수 기능**:
  - **연락처 허브**: CSV 대량 업로드, 전화번호 기준 중복 제거 및 병합, 기본 검색/필터 기능.
  - **메시징 엔진**: SMS/카카오 API 연동, Redis 기반 발송 큐, 채널 우선순위(Fallback) 로직 구현.
- **기본 보안**: RLS를 통한 테넌트 데이터 격리, 주요 개인정보 컬럼 암호화.
- **개발 환경**: CI/CD 파이프라인 기초 설정 (GitHub Actions).
- **예상 기간**: 1주차 ~ 7주차

### 2단계: 기능 고도화
- **고급 기능**:
  - **성과 분석**: 발송 성공/실패/열람률 실시간 대시보드 구현.
  - **쿼터 관리**: 테넌트별 월간 발송량 제한 및 하드 스톱 기능 구현.
- **성능 최적화**: 1단계에서 구현된 기능에 대한 부하 테스트 및 성능 튜닝. 데이터베이스 쿼리 최적화 및 인덱스 전략 개선.
- **보안 강화**: 상세 활동 로그 기록, 주요 API에 대한 Rate Limiting 적용.
- **모니터링 구현**: Prometheus 및 Grafana를 이용한 핵심 지표 모니터링 대시보드 구축.
- **예상 기간**: 8주차 이후 (베타 운영 및 피드백 반영)

## 6. 리스크 분석 및 완화 전략
### 기술 리스크 분석
- **기술 리스크**: 대용량(100K+) 데이터 처리 시 성능 저하 발생 가능성.
  - **완화 전략**: 백그라운드 작업, 데이터 스트리밍 처리, PostgreSQL `COPY` 프로토콜 사용. 사전에 100만 건 이상의 데이터로 부하 테스트를 진행하여 병목 구간을 식별하고 최적화합니다.
- **성능 리스크**: 동시 발송 요청이 많을 경우 메시지 큐에 병목이 발생하거나 발송 지연이 심화될 수 있음.
  - **완화 전략**: Redis 클러스터 구성을 고려하고, 발송 워커 프로세스를 수평적으로 확장(Scale-out)할 수 있도록 설계합니다. 발송 우선순위 큐를 도입하여 긴급한 메시지를 먼저 처리하는 로직을 추가합니다.
- **보안 리스크**: 개인정보(PII) 데이터 유출 또는 테넌트 간 데이터 노출 가능성.
  - **완화 전략**: PostgreSQL의 RLS(Row-Level Security)를 철저히 적용하여 쿼리 레벨에서 데이터 접근을 원천 차단합니다. `pgcrypto`를 사용하여 저장 시점(at-rest)에 데이터를 암호화하고, 모든 API 통신은 HTTPS를 강제합니다.
- **통합 리스크**: 외부 SMS/카카오 API 서비스의 장애 또는 응답 지연이 전체 시스템에 영향을 줄 수 있음.
  - **완화 전략**: API 호출 시 서킷 브레이커(Circuit Breaker) 패턴을 적용하여 장애 전파를 방지합니다. 재시도 로직을 구현하고, API 제공업체의 상태 페이지를 모니터링하여 장애 발생 시 관리자에게 즉시 알림을 보냅니다.

### 프로젝트 수행 리스크
- **일정 리스크**: 카카오 비즈니스 채널 인증 절차가 예상보다 지연되어 메시징 기능 개발이 중단될 수 있음.
  - **완화 전략**: 프로젝트 초기에 인증 서류를 미리 준비하고 제출합니다. 인증 지연 시, SMS 발송 기능을 우선적으로 개발 및 오픈하여 MVP 릴리즈 일정을 준수하는 비상 계획을 수립합니다.
- **자원 리스크**: 팀 내에 .NET 또는 PostgreSQL RLS에 대한 전문성이 부족할 경우 개발 생산성이 저하될 수 있음.
  - **완화 전략**: 공식 문서 및 커뮤니티를 활용한 스터디를 병행하고, 복잡한 부분은 페어 프로그래밍을 통해 지식을 공유합니다. 필요한 경우 외부 전문가의 코드 리뷰나 단기 자문을 구합니다.
- **품질 리스크**: 신속한 개발 일정으로 인해 테스트 커버리지가 부족하여 릴리즈 후 버그가 다수 발생할 수 있음.
  - **완화 전략**: 핵심 비즈니스 로직(중복 제거, 발송 큐)에 대해서는 단위 테스트 및 통합 테스트를 의무화합니다. 릴리즈 전, 주요 사용자 시나리오에 대한 E2E(End-to-End) 테스트를 수행합니다.
- **배포 리스크**: 베어메탈 서버 환경 구성의 복잡성으로 인해 초기 배포에 어려움을 겪거나 장애가 발생할 수 있음.
  - **완화 전략**: Docker를 사용하여 환경 의존성을 최소화합니다. 배포 스크립트를 작성하여 과정을 자동화하고, 주요 설정값은 환경 변수로 관리하여 이식성을 높입니다. 배포 전 스테이징 환경에서 충분한 검증을 거칩니다.